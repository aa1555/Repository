# 基础语法练习

## 1. Hello World

```python
# 输出Hello World
print("Hello, World!")
```

## 2. 变量赋值

```python
# 创建变量并赋值
name = "Python"
age = 30
height = 1.75
print(f"语言: {name}, 年龄: {age}, 版本: {height}")
```

## 3. 用户输入

```python
# 获取用户输入
name = input("请输入您的姓名: ")
print(f"您好, {name}!")
```

## 4. 数据类型检查

```python
# 检查数据类型
num = 42
text = "Hello"
flag = True
print(f"num的类型: {type(num)}")
print(f"text的类型: {type(text)}")
print(f"flag的类型: {type(flag)}")
```

## 5. 基本运算

```python
# 基本数学运算
a = 10
b = 3
print(f"加法: {a + b}")
print(f"减法: {a - b}")
print(f"乘法: {a * b}")
print(f"除法: {a / b}")
print(f"整除: {a // b}")
print(f"取余: {a % b}")
print(f"幂运算: {a ** b}")
```

## 6. 字符串操作

```python
# 字符串基本操作
text = "Python Programming"
print(f"原字符串: {text}")
print(f"转大写: {text.upper()}")
print(f"转小写: {text.lower()}")
print(f"字符串长度: {len(text)}")
print(f"替换: {text.replace('Python', 'Java')}")
```

## 7. 字符串格式化

```python
# 字符串格式化的不同方法
name = "张三"
age = 25
score = 95.5

# 方法1: f-string
print(f"姓名: {name}, 年龄: {age}, 分数: {score:.1f}")

# 方法2: format方法
print("姓名: {}, 年龄: {}, 分数: {:.1f}".format(name, age, score))

# 方法3: %格式化
print("姓名: %s, 年龄: %d, 分数: %.1f" % (name, age, score))
```

## 8. 注释练习

```python
# 这是单行注释
print("Hello")  # 行末注释

"""
这是多行注释
可以写很多行
用于详细说明
"""
print("World")
```

## 9. 常量定义

```python
# Python中的常量约定（使用大写字母）
PI = 3.14159
MAX_SIZE = 100
APP_NAME = "我的应用"

print(f"圆周率: {PI}")
print(f"最大尺寸: {MAX_SIZE}")
print(f"应用名称: {APP_NAME}")
```

## 10. 多变量赋值

```python
# 多变量同时赋值
a, b, c = 1, 2, 3
print(f"a={a}, b={b}, c={c}")

# 交换变量值
x, y = 10, 20
print(f"交换前: x={x}, y={y}")
x, y = y, x
print(f"交换后: x={x}, y={y}")
```

## 11. 转义字符

```python
# 转义字符的使用
print("第一行\n第二行")  # 换行
print("制表符\t分隔")
print("引号: \"Hello\"")
print("反斜杠: \\")
print("回车: \r覆盖")
```

## 12. 原始字符串

```python
# 原始字符串（r-string）
path = r"C:\Users\Documents\file.txt"
regex = r"\d+\w*"
print(f"文件路径: {path}")
print(f"正则表达式: {regex}")
```

## 13. 字符串切片

```python
# 字符串切片操作
text = "Python Programming"
print(f"前6个字符: {text[:6]}")
print(f"后11个字符: {text[7:]}")
print(f"中间部分: {text[7:18]}")
print(f"每隔一个字符: {text[::2]}")
print(f"反转字符串: {text[::-1]}")
```

## 14. 字符串判断

```python
# 字符串内容判断
text = "Python123"
print(f"是否为数字: {text.isdigit()}")
print(f"是否为字母: {text.isalpha()}")
print(f"是否为字母数字: {text.isalnum()}")
print(f"是否为小写: {text.islower()}")
print(f"是否为大写: {text.isupper()}")
```

## 15. 输入类型转换

```python
# 输入数据类型转换
try:
    age = int(input("请输入您的年龄: "))
    height = float(input("请输入您的身高(米): "))
    print(f"您今年{age}岁，身高{height}米")
except ValueError:
    print("输入格式错误！")
```

## 16. 布尔运算

```python
# 布尔运算和逻辑操作
a = True
b = False
print(f"a and b: {a and b}")
print(f"a or b: {a or b}")
print(f"not a: {not a}")
print(f"not b: {not b}")

# 比较运算
x, y = 5, 10
print(f"{x} > {y}: {x > y}")
print(f"{x} < {y}: {x < y}")
print(f"{x} == {y}: {x == y}")
print(f"{x} != {y}: {x != y}")
```

## 17. 成员运算符

```python
# in 和 not in 运算符
text = "Hello World"
print(f"'Hello' in text: {'Hello' in text}")
print(f"'Python' in text: {'Python' in text}")
print(f"'Python' not in text: {'Python' not in text}")

numbers = [1, 2, 3, 4, 5]
print(f"3 in numbers: {3 in numbers}")
print(f"6 in numbers: {6 in numbers}")
```

## 18. 身份运算符

```python
# is 和 is not 运算符
a = [1, 2, 3]
b = [1, 2, 3]
c = a

print(f"a == b: {a == b}")  # 值相等
print(f"a is b: {a is b}")  # 不是同一个对象
print(f"a is c: {a is c}")  # 是同一个对象

x = None
print(f"x is None: {x is None}")
print(f"x is not None: {x is not None}")
```

## 19. 运算符优先级

```python
# 运算符优先级示例
result1 = 2 + 3 * 4  # 乘法优先
result2 = (2 + 3) * 4  # 括号改变优先级
result3 = 2 ** 3 ** 2  # 幂运算从右到左
result4 = 2 ** (3 ** 2)  # 明确优先级

print(f"2 + 3 * 4 = {result1}")
print(f"(2 + 3) * 4 = {result2}")
print(f"2 ** 3 ** 2 = {result3}")
print(f"2 ** (3 ** 2) = {result4}")
```

## 20. 简单计算器

```python
# 简单的计算器程序
def simple_calculator():
    try:
        num1 = float(input("请输入第一个数字: "))
        operator = input("请输入运算符 (+, -, *, /): ")
        num2 = float(input("请输入第二个数字: "))
        
        if operator == '+':
            result = num1 + num2
        elif operator == '-':
            result = num1 - num2
        elif operator == '*':
            result = num1 * num2
        elif operator == '/':
            if num2 != 0:
                result = num1 / num2
            else:
                print("错误：除数不能为零！")
                return
        else:
            print("错误：不支持的运算符！")
            return
        
        print(f"结果: {num1} {operator} {num2} = {result}")
    except ValueError:
        print("错误：请输入有效的数字！")

# simple_calculator()  # 取消注释来运行
```

---

# 数据类型练习

## 21. 列表基础操作

```python
# 列表的创建和基本操作
fruits = ["苹果", "香蕉", "橙子"]
print(f"原列表: {fruits}")

# 添加元素
fruits.append("葡萄")
print(f"添加后: {fruits}")

# 插入元素
fruits.insert(1, "草莓")
print(f"插入后: {fruits}")

# 删除元素
fruits.remove("香蕉")
print(f"删除后: {fruits}")

# 访问元素
print(f"第一个水果: {fruits[0]}")
print(f"最后一个水果: {fruits[-1]}")
```

## 22. 列表切片和遍历

```python
# 列表切片和遍历
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 切片操作
print(f"前5个数字: {numbers[:5]}")
print(f"后5个数字: {numbers[5:]}")
print(f"偶数位置: {numbers[::2]}")
print(f"反转列表: {numbers[::-1]}")

# 遍历列表
print("\n遍历列表:")
for i, num in enumerate(numbers):
    print(f"索引{i}: {num}")
```

## 23. 列表推导式

```python
# 列表推导式
# 生成平方数
squares = [x**2 for x in range(1, 11)]
print(f"平方数: {squares}")

# 筛选偶数
even_numbers = [x for x in range(1, 21) if x % 2 == 0]
print(f"偶数: {even_numbers}")

# 字符串处理
words = ["hello", "world", "python"]
capitalized = [word.capitalize() for word in words]
print(f"首字母大写: {capitalized}")
```

## 24. 元组操作

```python
# 元组的创建和操作
coordinates = (3, 4)
print(f"坐标: {coordinates}")
print(f"x坐标: {coordinates[0]}")
print(f"y坐标: {coordinates[1]}")

# 元组解包
x, y = coordinates
print(f"解包后: x={x}, y={y}")

# 命名元组
from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(3, 4)
print(f"命名元组: {p}")
print(f"x坐标: {p.x}, y坐标: {p.y}")
```

## 25. 字典基础操作

```python
# 字典的创建和操作
student = {
    "姓名": "张三",
    "年龄": 20,
    "专业": "计算机科学",
    "成绩": [85, 92, 78]
}

print(f"学生信息: {student}")
print(f"姓名: {student['姓名']}")
print(f"年龄: {student.get('年龄', '未知')}")

# 添加和修改
student["学号"] = "2023001"
student["年龄"] = 21
print(f"更新后: {student}")

# 遍历字典
for key, value in student.items():
    print(f"{key}: {value}")
```

## 26. 字典推导式

```python
# 字典推导式
# 创建平方字典
square_dict = {x: x**2 for x in range(1, 6)}
print(f"平方字典: {square_dict}")

# 筛选字典
scores = {"张三": 85, "李四": 92, "王五": 78, "赵六": 95}
high_scores = {name: score for name, score in scores.items() if score >= 90}
print(f"高分学生: {high_scores}")

# 字符串长度字典
words = ["python", "java", "javascript", "go"]
length_dict = {word: len(word) for word in words}
print(f"单词长度: {length_dict}")
```

## 27. 集合操作

```python
# 集合的创建和操作
set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

print(f"集合1: {set1}")
print(f"集合2: {set2}")

# 集合运算
print(f"并集: {set1 | set2}")
print(f"交集: {set1 & set2}")
print(f"差集: {set1 - set2}")
print(f"对称差集: {set1 ^ set2}")

# 集合方法
set1.add(6)
print(f"添加元素后: {set1}")
set1.discard(1)
print(f"删除元素后: {set1}")
```

## 28. 字符串方法详解

```python
# 字符串方法详细示例
text = "  Hello, Python World!  "

print(f"原字符串: '{text}'")
print(f"去除空格: '{text.strip()}'")
print(f"分割字符串: {text.strip().split(', ')}")
print(f"连接字符串: {'-'.join(['a', 'b', 'c'])}")
print(f"查找子串: {text.find('Python')}")
print(f"替换字符串: {text.replace('World', 'Universe')}")
print(f"字符串居中: '{text.strip().center(30, '*')}'")
```

## 29. 数字类型转换

```python
# 数字类型转换和操作
# 整数
num_int = 42
print(f"整数: {num_int}, 类型: {type(num_int)}")

# 浮点数
num_float = 3.14159
print(f"浮点数: {num_float}, 类型: {type(num_float)}")

# 复数
num_complex = 3 + 4j
print(f"复数: {num_complex}, 类型: {type(num_complex)}")
print(f"实部: {num_complex.real}, 虚部: {num_complex.imag}")

# 类型转换
print(f"浮点转整数: {int(num_float)}")
print(f"整数转浮点: {float(num_int)}")
print(f"字符串转数字: {int('123')}, {float('3.14')}")
```

## 30. 数据类型判断

```python
# 数据类型判断
def check_type(value):
    print(f"值: {value}")
    print(f"类型: {type(value)}")
    print(f"是否为整数: {isinstance(value, int)}")
    print(f"是否为字符串: {isinstance(value, str)}")
    print(f"是否为列表: {isinstance(value, list)}")
    print(f"是否为数字: {isinstance(value, (int, float))}")
    print("-" * 30)

# 测试不同类型
check_type(42)
check_type("Hello")
check_type([1, 2, 3])
check_type(3.14)
```

## 31. 嵌套数据结构

```python
# 嵌套数据结构
company = {
    "名称": "科技公司",
    "部门": {
        "研发部": {
            "员工": ["张三", "李四", "王五"],
            "项目": ["项目A", "项目B"]
        },
        "销售部": {
            "员工": ["赵六", "钱七"],
            "目标": 1000000
        }
    }
}

print(f"公司名称: {company['名称']}")
print(f"研发部员工: {company['部门']['研发部']['员工']}")
print(f"销售部目标: {company['部门']['销售部']['目标']}")

# 遍历嵌套结构
for dept_name, dept_info in company["部门"].items():
    print(f"\n{dept_name}:")
    for key, value in dept_info.items():
        print(f"  {key}: {value}")
```

## 32. 列表排序和搜索

```python
# 列表排序和搜索
numbers = [64, 34, 25, 12, 22, 11, 90]
print(f"原列表: {numbers}")

# 排序
sorted_asc = sorted(numbers)
sorted_desc = sorted(numbers, reverse=True)
print(f"升序排序: {sorted_asc}")
print(f"降序排序: {sorted_desc}")

# 原地排序
numbers.sort()
print(f"原地排序: {numbers}")

# 搜索
target = 25
if target in numbers:
    index = numbers.index(target)
    print(f"找到 {target}，位置: {index}")
else:
    print(f"未找到 {target}")
```

## 33. 字符串编码解码

```python
# 字符串编码和解码
text = "你好，Python！"
print(f"原字符串: {text}")

# 编码
utf8_bytes = text.encode('utf-8')
gbk_bytes = text.encode('gbk')
print(f"UTF-8编码: {utf8_bytes}")
print(f"GBK编码: {gbk_bytes}")

# 解码
decoded_utf8 = utf8_bytes.decode('utf-8')
decoded_gbk = gbk_bytes.decode('gbk')
print(f"UTF-8解码: {decoded_utf8}")
print(f"GBK解码: {decoded_gbk}")

# 处理编码错误
try:
    wrong_decode = utf8_bytes.decode('ascii')
except UnicodeDecodeError as e:
    print(f"解码错误: {e}")
```

## 34. 数据结构转换

```python
# 数据结构之间的转换
# 列表转换
list_data = [1, 2, 3, 4, 5]
tuple_data = tuple(list_data)
set_data = set(list_data)
print(f"列表: {list_data}")
print(f"元组: {tuple_data}")
print(f"集合: {set_data}")

# 字符串转换
string_data = "hello"
list_from_string = list(string_data)
tuple_from_string = tuple(string_data)
set_from_string = set(string_data)
print(f"\n字符串: {string_data}")
print(f"转列表: {list_from_string}")
print(f"转元组: {tuple_from_string}")
print(f"转集合: {set_from_string}")

# 字典转换
dict_data = {"a": 1, "b": 2, "c": 3}
keys_list = list(dict_data.keys())
values_list = list(dict_data.values())
items_list = list(dict_data.items())
print(f"\n字典: {dict_data}")
print(f"键列表: {keys_list}")
print(f"值列表: {values_list}")
print(f"项列表: {items_list}")
```

## 35. 深拷贝和浅拷贝

```python
# 深拷贝和浅拷贝
import copy

# 原始数据
original = [[1, 2, 3], [4, 5, 6]]
print(f"原始数据: {original}")

# 浅拷贝
shallow_copy = copy.copy(original)
shallow_copy[0][0] = 999
print(f"浅拷贝修改后原始数据: {original}")
print(f"浅拷贝数据: {shallow_copy}")

# 重置数据
original = [[1, 2, 3], [4, 5, 6]]

# 深拷贝
deep_copy = copy.deepcopy(original)
deep_copy[0][0] = 999
print(f"\n深拷贝修改后原始数据: {original}")
print(f"深拷贝数据: {deep_copy}")
```

## 36. 数据统计

```python
# 数据统计分析
numbers = [85, 92, 78, 96, 87, 91, 83, 89, 94, 88]

# 基本统计
print(f"数据: {numbers}")
print(f"总数: {len(numbers)}")
print(f"最大值: {max(numbers)}")
print(f"最小值: {min(numbers)}")
print(f"总和: {sum(numbers)}")
print(f"平均值: {sum(numbers) / len(numbers):.2f}")

# 排序后的统计
sorted_numbers = sorted(numbers)
print(f"排序后: {sorted_numbers}")
print(f"中位数: {sorted_numbers[len(sorted_numbers)//2]}")

# 计数统计
from collections import Counter
counter = Counter(numbers)
print(f"计数统计: {counter}")
print(f"最常见的3个: {counter.most_common(3)}")
```

## 37. 字符串格式化高级用法

```python
# 字符串格式化高级用法
name = "张三"
age = 25
score = 95.678

# f-string高级格式化
print(f"姓名: {name:>10}")  # 右对齐，宽度10
print(f"年龄: {age:0>5}")   # 用0填充，宽度5
print(f"分数: {score:.2f}")  # 保留2位小数
print(f"分数: {score:8.2f}")  # 宽度8，保留2位小数
print(f"百分比: {score/100:.2%}")  # 百分比格式

# 数字格式化
number = 1234567
print(f"千分位分隔: {number:,}")
print(f"科学计数法: {number:.2e}")

# 日期格式化
from datetime import datetime
now = datetime.now()
print(f"当前时间: {now:%Y-%m-%d %H:%M:%S}")
```

## 38. 数据验证

```python
# 数据验证函数
def validate_data(data):
    """验证数据的有效性"""
    results = {}
    
    # 检查是否为空
    results['is_empty'] = len(data) == 0
    
    # 检查数据类型
    results['all_numbers'] = all(isinstance(x, (int, float)) for x in data)
    results['all_strings'] = all(isinstance(x, str) for x in data)
    
    # 检查数值范围（如果是数字）
    if results['all_numbers']:
        results['all_positive'] = all(x > 0 for x in data)
        results['in_range_0_100'] = all(0 <= x <= 100 for x in data)
    
    # 检查字符串（如果是字符串）
    if results['all_strings']:
        results['all_non_empty'] = all(len(x.strip()) > 0 for x in data)
        results['all_alpha'] = all(x.isalpha() for x in data)
    
    return results

# 测试数据验证
test_data1 = [85, 92, 78, 96]
test_data2 = ["张三", "李四", "王五"]
test_data3 = []

print("数字数据验证:", validate_data(test_data1))
print("字符串数据验证:", validate_data(test_data2))
print("空数据验证:", validate_data(test_data3))
```

## 39. 数据过滤和映射

```python
# 数据过滤和映射
data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 使用filter过滤
even_numbers = list(filter(lambda x: x % 2 == 0, data))
print(f"偶数: {even_numbers}")

# 使用map映射
squared_numbers = list(map(lambda x: x**2, data))
print(f"平方数: {squared_numbers}")

# 使用列表推导式（更Pythonic）
even_squares = [x**2 for x in data if x % 2 == 0]
print(f"偶数的平方: {even_squares}")

# 字符串处理
words = ["hello", "world", "python", "programming"]
# 过滤长度大于5的单词并转大写
long_words_upper = [word.upper() for word in words if len(word) > 5]
print(f"长单词大写: {long_words_upper}")
```

## 40. 数据分组

```python
# 数据分组
from itertools import groupby
from collections import defaultdict

# 学生数据
students = [
    {"姓名": "张三", "班级": "A班", "分数": 85},
    {"姓名": "李四", "班级": "B班", "分数": 92},
    {"姓名": "王五", "班级": "A班", "分数": 78},
    {"姓名": "赵六", "班级": "B班", "分数": 96},
    {"姓名": "钱七", "班级": "A班", "分数": 89}
]

# 按班级分组
class_groups = defaultdict(list)
for student in students:
    class_groups[student["班级"]].append(student)

for class_name, students_in_class in class_groups.items():
    print(f"\n{class_name}:")
    for student in students_in_class:
        print(f"  {student['姓名']}: {student['分数']}分")
    
    # 计算班级平均分
    avg_score = sum(s["分数"] for s in students_in_class) / len(students_in_class)
    print(f"  平均分: {avg_score:.1f}")
```

---

# 控制结构练习

## 41. 条件判断基础

```python
# 基础条件判断
score = 85

if score >= 90:
    grade = "优秀"
elif score >= 80:
    grade = "良好"
elif score >= 70:
    grade = "中等"
elif score >= 60:
    grade = "及格"
else:
    grade = "不及格"

print(f"分数: {score}, 等级: {grade}")
```

## 42. 多条件判断

```python
# 多条件判断
age = 25
income = 50000
has_job = True

# 贷款审批条件
if age >= 18 and income >= 30000 and has_job:
    if age < 65 and income >= 50000:
        loan_amount = 500000
    else:
        loan_amount = 200000
    print(f"贷款审批通过，额度: {loan_amount}元")
else:
    print("贷款审批未通过")
    if age < 18:
        print("原因: 年龄不足")
    if income < 30000:
        print("原因: 收入不足")
    if not has_job:
        print("原因: 无工作")
```

## 43. 三元运算符

```python
# 三元运算符（条件表达式）
a = 10
b = 20

# 传统if-else
if a > b:
    max_value = a
else:
    max_value = b

# 三元运算符
max_value_ternary = a if a > b else b

print(f"较大值: {max_value}")
print(f"三元运算符结果: {max_value_ternary}")

# 复杂的三元运算符
status = "成年人" if age >= 18 else "未成年人"
print(f"状态: {status}")

# 嵌套三元运算符
grade = "优" if score >= 90 else "良" if score >= 80 else "中" if score >= 70 else "差"
print(f"等级: {grade}")
```

## 44. for循环基础

```python
# for循环基础用法
# 遍历数字
print("数字遍历:")
for i in range(5):
    print(f"数字: {i}")

# 遍历列表
fruits = ["苹果", "香蕉", "橙子"]
print("\n水果遍历:")
for fruit in fruits:
    print(f"水果: {fruit}")

# 遍历字符串
print("\n字符遍历:")
for char in "Python":
    print(f"字符: {char}")

# 带索引的遍历
print("\n带索引遍历:")
for index, fruit in enumerate(fruits):
    print(f"索引{index}: {fruit}")
```

## 45. for循环高级用法

```python
# for循环高级用法
# range的不同用法
print("range(start, stop, step):")
for i in range(2, 10, 2):  # 从2开始，到10结束（不包含），步长为2
    print(f"偶数: {i}")

# 反向遍历
print("\n反向遍历:")
for i in range(10, 0, -1):
    print(f"倒数: {i}")

# 遍历多个列表
names = ["张三", "李四", "王五"]
ages = [25, 30, 35]
print("\n同时遍历多个列表:")
for name, age in zip(names, ages):
    print(f"{name}: {age}岁")

# 嵌套循环
print("\n九九乘法表:")
for i in range(1, 10):
    for j in range(1, i + 1):
        print(f"{j}×{i}={i*j}", end="\t")
    print()  # 换行
```

## 46. while循环

```python
# while循环
# 基础while循环
count = 0
print("基础while循环:")
while count < 5:
    print(f"计数: {count}")
    count += 1

# 用户输入循环
print("\n猜数字游戏:")
import random
target = random.randint(1, 100)
guess_count = 0

while True:
    try:
        guess = int(input("请猜一个1-100的数字 (输入0退出): "))
        if guess == 0:
            print("游戏结束")
            break
        
        guess_count += 1
        
        if guess == target:
            print(f"恭喜！你猜对了！用了{guess_count}次")
            break
        elif guess < target:
            print("太小了")
        else:
            print("太大了")
            
    except ValueError:
        print("请输入有效数字")
```

## 47. break和continue

```python
# break和continue的使用
# break示例
print("break示例 - 找到第一个偶数:")
numbers = [1, 3, 5, 8, 9, 10, 11]
for num in numbers:
    if num % 2 == 0:
        print(f"找到第一个偶数: {num}")
        break
    print(f"检查数字: {num}")

# continue示例
print("\ncontinue示例 - 跳过偶数:")
for num in range(1, 11):
    if num % 2 == 0:
        continue  # 跳过偶数
    print(f"奇数: {num}")

# 嵌套循环中的break和continue
print("\n嵌套循环示例:")
for i in range(3):
    print(f"外层循环: {i}")
    for j in range(5):
        if j == 3:
            break  # 只跳出内层循环
        print(f"  内层循环: {j}")
```

## 48. else子句

```python
# for-else和while-else
# for-else: 循环正常结束时执行else
print("for-else示例:")
numbers = [2, 4, 6, 8, 10]
for num in numbers:
    if num % 2 != 0:
        print(f"找到奇数: {num}")
        break
else:
    print("所有数字都是偶数")

# while-else示例
print("\nwhile-else示例:")
count = 0
while count < 3:
    print(f"计数: {count}")
    count += 1
else:
    print("while循环正常结束")

# 带break的情况
print("\n带break的for-else:")
for num in range(10):
    if num == 5:
        print("找到5，跳出循环")
        break
    print(num)
else:
    print("这行不会执行，因为有break")
```

## 49. 循环优化

```python
# 循环优化技巧
import time

# 避免重复计算
print("优化前 - 重复计算:")
start_time = time.time()
data = list(range(1000))
result = []
for i in range(len(data)):
    if len(data) > 500:  # 每次都计算len(data)
        result.append(data[i] * 2)
end_time = time.time()
print(f"耗时: {end_time - start_time:.6f}秒")

# 优化后 - 避免重复计算
print("\n优化后 - 避免重复计算:")
start_time = time.time()
data = list(range(1000))
result = []
data_len = len(data)  # 只计算一次
for i in range(data_len):
    if data_len > 500:
        result.append(data[i] * 2)
end_time = time.time()
print(f"耗时: {end_time - start_time:.6f}秒")

# 使用列表推导式
print("\n使用列表推导式:")
start_time = time.time()
data = list(range(1000))
result = [x * 2 for x in data if len(data) > 500]
end_time = time.time()
print(f"耗时: {end_time - start_time:.6f}秒")
```

## 50. 模式匹配（Python 3.10+）

```python
# 模式匹配 (match-case)
def handle_data(data):
    match data:
        case int() if data > 0:
            return f"正整数: {data}"
        case int() if data < 0:
            return f"负整数: {data}"
        case 0:
            return "零"
        case str() if len(data) > 0:
            return f"非空字符串: {data}"
        case []:
            return "空列表"
        case [x] if isinstance(x, int):
            return f"包含一个整数的列表: {x}"
        case [x, y]:
            return f"包含两个元素的列表: {x}, {y}"
        case {"name": name, "age": age}:
            return f"包含姓名和年龄的字典: {name}, {age}岁"
        case _:
            return f"其他类型: {type(data)}"

# 测试模式匹配
test_cases = [
    42, -10, 0, "Hello", [], [5], [1, 2], 
    {"name": "张三", "age": 25}, (1, 2, 3)
]

print("模式匹配示例:")
for case in test_cases:
    result = handle_data(case)
    print(f"{case} -> {result}")
```

## 51. 异常处理基础

```python
# 异常处理基础
def safe_divide(a, b):
    try:
        result = a / b
        return result
    except ZeroDivisionError:
        print("错误: 除数不能为零")
        return None
    except TypeError:
        print("错误: 参数类型不正确")
        return None
    except Exception as e:
        print(f"未知错误: {e}")
        return None
    finally:
        print("计算完成")

# 测试异常处理
print("异常处理测试:")
print(f"10 / 2 = {safe_divide(10, 2)}")
print(f"10 / 0 = {safe_divide(10, 0)}")
print(f"'10' / 2 = {safe_divide('10', 2)}")
```

## 52. 多重异常处理

```python
# 多重异常处理
def process_user_input():
    try:
        # 获取用户输入
        num_str = input("请输入一个数字: ")
        num = float(num_str)
        
        # 计算平方根
        if num < 0:
            raise ValueError("不能计算负数的平方根")
        
        result = num ** 0.5
        print(f"{num} 的平方根是 {result:.2f}")
        
    except ValueError as e:
        if "could not convert" in str(e):
            print("错误: 输入的不是有效数字")
        else:
            print(f"数值错误: {e}")
    except KeyboardInterrupt:
        print("\n用户中断了程序")
    except Exception as e:
        print(f"未预期的错误: {e}")
    else:
        print("计算成功完成")
    finally:
        print("程序执行结束")

# process_user_input()  # 取消注释来运行
```

## 53. 自定义异常

```python
# 自定义异常
class CustomError(Exception):
    """自定义异常基类"""
    pass

class AgeError(CustomError):
    """年龄相关异常"""
    def __init__(self, age, message="年龄值无效"):
  self.age = age
        self.message = message
        super().__init__(self.message)

class ScoreError(CustomError):
    """分数相关异常"""
    def __init__(self, score, message="分数值无效"):
        self.score = score
        self.message = message
        super().__init__(self.message)

def validate_student_info(name, age, score):
    """验证学生信息"""
    if not isinstance(name, str) or len(name.strip()) == 0:
        raise ValueError("姓名不能为空")
    
    if not isinstance(age, int) or age < 0 or age > 150:
        raise AgeError(age, f"年龄 {age} 不在有效范围内 (0-150)")
    
    if not isinstance(score, (int, float)) or score < 0 or score > 100:
        raise ScoreError(score, f"分数 {score} 不在有效范围内 (0-100)")
    
    return True

# 测试自定义异常
test_cases = [
    ("张三", 20, 85),
    ("", 20, 85),
    ("李四", -5, 85),
    ("王五", 20, 150)
]

for name, age, score in test_cases:
    try:
        validate_student_info(name, age, score)
        print(f"✓ {name} 的信息验证通过")
    except (ValueError, AgeError, ScoreError) as e:
        print(f"✗ 验证失败: {e}")
```

## 54. 断言

```python
# 断言的使用
def calculate_average(numbers):
    """计算平均值"""
    # 使用断言检查前置条件
    assert isinstance(numbers, list), "参数必须是列表"
    assert len(numbers) > 0, "列表不能为空"
    assert all(isinstance(x, (int, float)) for x in numbers), "列表元素必须是数字"
    
    total = sum(numbers)
    average = total / len(numbers)
    
    # 使用断言检查后置条件
    assert isinstance(average, (int, float)), "平均值必须是数字"
    
    return average

# 测试断言
test_data = [
    [1, 2, 3, 4, 5],
    [],  # 空列表
    [1, 2, "3", 4],  # 包含非数字
    "not a list"  # 不是列表
]

for data in test_data:
    try:
        result = calculate_average(data)
        print(f"✓ {data} 的平均值: {result}")
    except AssertionError as e:
        print(f"✗ 断言失败: {e}")
    except Exception as e:
        print(f"✗ 其他错误: {e}")
```

## 55. 上下文管理器

```python
# 上下文管理器
class Timer:
    """计时器上下文管理器"""
    def __init__(self, name="操作"):
        self.name = name
    
    def __enter__(self):
        import time
        self.start_time = time.time()
        print(f"开始 {self.name}...")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        import time
        end_time = time.time()
        duration = end_time - self.start_time
        print(f"{self.name} 完成，耗时: {duration:.4f}秒")
        
        if exc_type is not None:
            print(f"发生异常: {exc_type.__name__}: {exc_val}")
        return False  # 不抑制异常

# 使用上下文管理器
with Timer("数据处理"):
    # 模拟一些耗时操作
    import time
    time.sleep(0.1)
    data = [i**2 for i in range(1000)]
    print(f"处理了 {len(data)} 个数据")

# 使用contextlib简化上下文管理器
from contextlib import contextmanager

@contextmanager
def database_transaction():
    print("开始数据库事务")
    try:
        yield "数据库连接"
        print("提交事务")
    except Exception as e:
        print(f"回滚事务: {e}")
        raise
    finally:
        print("关闭数据库连接")

# 使用简化的上下文管理器
with database_transaction() as db:
    print(f"使用 {db} 执行操作")
    # 模拟数据库操作
```

## 56. 生成器基础

```python
# 生成器基础
def number_generator(n):
    """生成0到n-1的数字"""
    for i in range(n):
        print(f"生成数字: {i}")
        yield i

# 使用生成器
print("生成器示例:")
gen = number_generator(5)
print(f"生成器对象: {gen}")

# 逐个获取值
for num in gen:
    print(f"接收到: {num}")

# 斐波那契数列生成器
def fibonacci_generator(n):
    """生成斐波那契数列的前n项"""
    a, b = 0, 1
    count = 0
    while count < n:
        yield a
        a, b = b, a + b
        count += 1

print("\n斐波那契数列:")
fib_gen = fibonacci_generator(10)
fib_numbers = list(fib_gen)
print(f"前10项: {fib_numbers}")
```

## 57. 生成器表达式

```python
# 生成器表达式
# 与列表推导式的对比
print("列表推导式 vs 生成器表达式:")

# 列表推导式 - 立即创建所有元素
list_comp = [x**2 for x in range(10)]
print(f"列表推导式: {list_comp}")
print(f"内存占用: {list_comp.__sizeof__()} 字节")

# 生成器表达式 - 按需生成元素
gen_exp = (x**2 for x in range(10))
print(f"生成器表达式: {gen_exp}")
print(f"内存占用: {gen_exp.__sizeof__()} 字节")

# 使用生成器表达式
print("\n生成器表达式的值:")
for value in gen_exp:
    print(value, end=" ")
print()

# 大数据处理示例
def process_large_data():
    """处理大量数据的示例"""
    # 模拟大数据集
    large_data = range(1000000)
    
    # 使用生成器表达式节省内存
    even_squares = (x**2 for x in large_data if x % 2 == 0)
    
    # 只处理前10个结果
    result = []
    for i, value in enumerate(even_squares):
        if i >= 10:
            break
        result.append(value)
    
    return result

print("\n大数据处理结果:")
result = process_large_data()
print(f"前10个偶数的平方: {result}")
```

## 58. 迭代器

```python
# 自定义迭代器
class CountDown:
    """倒计时迭代器"""
    def __init__(self, start):
        self.start = start
    
    def __iter__(self):
        return self
    
    def __next__(self):
        if self.start <= 0:
            raise StopIteration
        self.start -= 1
        return self.start + 1

# 使用自定义迭代器
print("倒计时迭代器:")
countdown = CountDown(5)
for num in countdown:
    print(f"倒计时: {num}")

# 使用iter()函数
print("\n使用iter()函数:")
data = [1, 2, 3, 4, 5]
iterator = iter(data)

try:
    while True:
        value = next(iterator)
        print(f"迭代值: {value}")
except StopIteration:
    print("迭代结束")

# 无限迭代器
class InfiniteCounter:
    """无限计数器"""
    def __init__(self, start=0, step=1):
        self.current = start
        self.step = step
    
    def __iter__(self):
        return self
    
    def __next__(self):
        value = self.current
        self.current += self.step
        return value

# 使用无限迭代器（注意要有退出条件）
print("\n无限计数器（前10个值）:")
counter = InfiniteCounter(1, 2)
for i, value in enumerate(counter):
    if i >= 10:
        break
    print(f"第{i+1}个值: {value}")
```

## 59. 装饰器基础

```python
# 装饰器基础
def timer_decorator(func):
    """计时装饰器"""
    import time
    import functools
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} 执行时间: {end_time - start_time:.4f}秒")
        return result
    return wrapper

def log_decorator(func):
    """日志装饰器"""
    import functools
    
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print(f"调用函数: {func.__name__}")
        print(f"参数: args={args}, kwargs={kwargs}")
        result = func(*args, **kwargs)
        print(f"返回值: {result}")
        return result
    return wrapper

# 使用装饰器
@timer_decorator
@log_decorator
def calculate_sum(n):
    """计算1到n的和"""
    return sum(range(1, n + 1))

# 测试装饰器
print("装饰器测试:")
result = calculate_sum(1000)
print(f"最终结果: {result}")
```

## 60. 综合练习：学生管理系统

```python
# 综合练习：简单的学生管理系统
class StudentManager:
    """学生管理系统"""
    
    def __init__(self):
        self.students = {}
    
    def add_student(self, student_id, name, age, scores=None):
        """添加学生"""
        if student_id in self.students:
            raise ValueError(f"学号 {student_id} 已存在")
        
        if not isinstance(age, int) or age < 0 or age > 150:
            raise ValueError("年龄必须是0-150之间的整数")
        
        self.students[student_id] = {
            "name": name,
            "age": age,
            "scores": scores or []
        }
        print(f"✓ 学生 {name} (学号: {student_id}) 添加成功")
    
    def remove_student(self, student_id):
        """删除学生"""
        if student_id not in self.students:
            raise ValueError(f"学号 {student_id} 不存在")
        
        name = self.students[student_id]["name"]
        del self.students[student_id]
        print(f"✓ 学生 {name} (学号: {student_id}) 删除成功")
    
    def update_student(self, student_id, **kwargs):
        """更新学生信息"""
        if student_id not in self.students:
            raise ValueError(f"学号 {student_id} 不存在")
        
        student = self.students[student_id]
        for key, value in kwargs.items():
            if key in ["name", "age", "scores"]:
                student[key] = value
        
        print(f"✓ 学生 {student['name']} 信息更新成功")
    
    def add_score(self, student_id, score):
        """添加成绩"""
        if student_id not in self.students:
            raise ValueError(f"学号 {student_id} 不存在")
        
        if not isinstance(score, (int, float)) or score < 0 or score > 100:
            raise ValueError("成绩必须是0-100之间的数字")
        
        self.students[student_id]["scores"].append(score)
        print(f"✓ 成绩 {score} 添加成功")
    
    def get_student_average(self, student_id):
        """获取学生平均分"""
        if student_id not in self.students:
            raise ValueError(f"学号 {student_id} 不存在")
        
        scores = self.students[student_id]["scores"]
        if not scores:
            return 0
        
        return sum(scores) / len(scores)
    
    def list_students(self):
        """列出所有学生"""
        if not self.students:
            print("暂无学生信息")
            return
        
        print("\n学生列表:")
        print("-" * 60)
        for student_id, info in self.students.items():
            avg_score = self.get_student_average(student_id)
            print(f"学号: {student_id}")
            print(f"姓名: {info['name']}")
            print(f"年龄: {info['age']}")
            print(f"成绩: {info['scores']}")
            print(f"平均分: {avg_score:.2f}")
            print("-" * 60)
    
    def search_student(self, keyword):
        """搜索学生"""
        results = []
        for student_id, info in self.students.items():
            if (keyword.lower() in info["name"].lower() or 
                keyword in student_id):
                results.append((student_id, info))
        
        if results:
            print(f"\n找到 {len(results)} 个匹配结果:")
            for student_id, info in results:
                print(f"学号: {student_id}, 姓名: {info['name']}")
        else:
            print("未找到匹配的学生")

# 测试学生管理系统
if __name__ == "__main__":
    sm = StudentManager()
    
    try:
        # 添加学生
        sm.add_student("2023001", "张三", 20)
        sm.add_student("2023002", "李四", 21)
        sm.add_student("2023003", "王五", 19)
        
        # 添加成绩
        sm.add_score("2023001", 85)
        sm.add_score("2023001", 92)
        sm.add_score("2023002", 78)
        sm.add_score("2023002", 88)
        
        # 列出所有学生
        sm.list_students()
        
        # 搜索学生
        sm.search_student("张")
        
    except ValueError as e:
        print(f"错误: {e}")
```

---

# 函数练习

## 61. 函数基础定义

```python
# 函数基础定义和调用
def greet(name):
    """问候函数"""
    return f"你好, {name}!"

def add_numbers(a, b):
    """加法函数"""
    return a + b

def get_user_info():
    """获取用户信息（无参数函数）"""
    name = input("请输入姓名: ")
    age = int(input("请输入年龄: "))
    return name, age

# 调用函数
print(greet("张三"))
print(f"5 + 3 = {add_numbers(5, 3)}")

# name, age = get_user_info()  # 取消注释来运行
# print(f"用户信息: {name}, {age}岁")
```

## 62. 参数类型

```python
# 不同类型的参数
def function_parameters(required, default_param="默认值", *args, **kwargs):
    """演示不同类型的参数"""
    print(f"必需参数: {required}")
    print(f"默认参数: {default_param}")
    print(f"可变位置参数: {args}")
    print(f"可变关键字参数: {kwargs}")
    print("-" * 30)

# 测试不同的调用方式
function_parameters("必需值")
function_parameters("必需值", "自定义默认值")
function_parameters("必需值", "自定义默认值", 1, 2, 3)
function_parameters("必需值", extra1="额外1", extra2="额外2")
function_parameters("必需值", "自定义", 1, 2, name="张三", age=25)
```

## 63. 关键字参数

```python
# 关键字参数和位置参数
def create_profile(name, age, city="未知", *, email, phone=None):
    """创建用户档案
    
    Args:
        name: 姓名（位置参数）
        age: 年龄（位置参数）
        city: 城市（默认参数）
        email: 邮箱（仅关键字参数）
        phone: 电话（仅关键字参数，可选）
    """
    profile = {
        "姓名": name,
        "年龄": age,
        "城市": city,
        "邮箱": email
    }
    
    if phone:
        profile["电话"] = phone
    
    return profile

# 正确的调用方式
profile1 = create_profile("张三", 25, email="zhang@example.com")
profile2 = create_profile("李四", 30, "北京", email="li@example.com", phone="123456789")

print("档案1:", profile1)
print("档案2:", profile2)

# 错误的调用方式（会报错）
# profile3 = create_profile("王五", 28, "上海", "wang@example.com")  # email必须用关键字
```

## 64. 函数作为参数

```python
# 函数作为参数（高阶函数）
def apply_operation(numbers, operation):
    """对数字列表应用操作"""
    return [operation(num) for num in numbers]

def square(x):
    """平方函数"""
    return x ** 2

def cube(x):
    """立方函数"""
    return x ** 3

def double(x):
    """双倍函数"""
    return x * 2

# 使用函数作为参数
numbers = [1, 2, 3, 4, 5]

print(f"原数字: {numbers}")
print(f"平方: {apply_operation(numbers, square)}")
print(f"立方: {apply_operation(numbers, cube)}")
print(f"双倍: {apply_operation(numbers, double)}")

# 使用lambda函数
print(f"加10: {apply_operation(numbers, lambda x: x + 10)}")
```

## 65. 返回函数

```python
# 返回函数（闭包）
def create_multiplier(factor):
    """创建乘法器函数"""
    def multiplier(x):
        return x * factor
    return multiplier

def create_counter(start=0):
    """创建计数器函数"""
    count = start
    
    def counter():
        nonlocal count
        count += 1
        return count
    
    return counter

# 使用返回的函数
double_func = create_multiplier(2)
triple_func = create_multiplier(3)

print(f"5 * 2 = {double_func(5)}")
print(f"5 * 3 = {triple_func(5)}")

# 使用计数器
counter1 = create_counter()
counter2 = create_counter(10)

print(f"计数器1: {counter1()}, {counter1()}, {counter1()}")
print(f"计数器2: {counter2()}, {counter2()}, {counter2()}")
```

## 66. 递归函数

```python
# 递归函数
def factorial(n):
    """计算阶乘"""
    if n <= 1:
        return 1
    return n * factorial(n - 1)

def fibonacci(n):
    """计算斐波那契数列第n项"""
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

def fibonacci_memo(n, memo={}):
    """带记忆化的斐波那契数列"""
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
    return memo[n]

# 测试递归函数
print(f"5的阶乘: {factorial(5)}")
print(f"斐波那契数列前10项:")
for i in range(10):
    print(f"F({i}) = {fibonacci_memo(i)}")
```

## 67. 装饰器函数

```python
# 装饰器函数
def retry(max_attempts=3):
    """重试装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise e
                    print(f"第{attempt + 1}次尝试失败: {e}")
            return None
        return wrapper
    return decorator

def validate_types(**types):
    """类型验证装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            # 验证位置参数
            import inspect
            sig = inspect.signature(func)
            bound_args = sig.bind(*args, **kwargs)
            bound_args.apply_defaults()
            
            for param_name, expected_type in types.items():
                if param_name in bound_args.arguments:
                    value = bound_args.arguments[param_name]
                    if not isinstance(value, expected_type):
                        raise TypeError(f"参数 {param_name} 应该是 {expected_type.__name__} 类型")
            
            return func(*args, **kwargs)
        return wrapper
    return decorator

# 使用装饰器
@retry(max_attempts=3)
def unreliable_function():
    import random
    if random.random() < 0.7:
        raise Exception("随机失败")
    return "成功!"

@validate_types(name=str, age=int)
def create_person(name, age):
    return f"创建了 {name}, 年龄 {age}"

# 测试装饰器
try:
    result = unreliable_function()
    print(f"结果: {result}")
except Exception as e:
    print(f"最终失败: {e}")

try:
    person = create_person("张三", 25)
    print(person)
    # person = create_person("李四", "25")  # 会报错
except TypeError as e:
    print(f"类型错误: {e}")
```

## 68. 生成器函数

```python
# 生成器函数
def read_file_lines(filename):
    """逐行读取文件的生成器"""
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            for line_num, line in enumerate(file, 1):
                yield line_num, line.strip()
    except FileNotFoundError:
        print(f"文件 {filename} 不存在")

def prime_generator(limit):
    """生成质数的生成器"""
    def is_prime(n):
        if n < 2:
            return False
        for i in range(2, int(n ** 0.5) + 1):
            if n % i == 0:
                return False
        return True
    
    for num in range(2, limit + 1):
        if is_prime(num):
            yield num

def batch_generator(data, batch_size):
    """批量处理数据的生成器"""
    for i in range(0, len(data), batch_size):
        yield data[i:i + batch_size]

# 使用生成器
print("前20个质数:")
primes = list(prime_generator(100))
print(primes[:20])

print("\n批量处理数据:")
data = list(range(1, 21))
for batch in batch_generator(data, 5):
    print(f"批次: {batch}")
```

## 69. 函数注解

```python
# 函数注解
def calculate_area(length: float, width: float) -> float:
    """计算矩形面积
    
    Args:
        length: 长度
        width: 宽度
    
    Returns:
        面积
    """
    return length * width

def process_data(data: list[int], multiplier: int = 2) -> list[int]:
    """处理数据"""
    return [x * multiplier for x in data]

from typing import Union, Optional, Dict, List

def advanced_function(
    name: str,
    age: int,
    scores: Optional[List[float]] = None,
    metadata: Dict[str, Union[str, int]] = None
) -> Dict[str, Union[str, int, float]]:
    """高级函数注解示例"""
    result = {
        "name": name,
        "age": age
    }
    
    if scores:
        result["average_score"] = sum(scores) / len(scores)
    
    if metadata:
        result.update(metadata)
    
    return result

# 使用带注解的函数
area = calculate_area(10.5, 8.2)
print(f"面积: {area}")

processed = process_data([1, 2, 3, 4, 5], 3)
print(f"处理后的数据: {processed}")

result = advanced_function(
    "张三", 
    25, 
    [85.5, 92.0, 78.5], 
    {"city": "北京", "grade": (((3}
)
print(f"高级函数结果: {result}")
```

## 70. 偏函数

```python
# 偏函数
from functools import partial

def power(base, exponent):
    """计算幂"""
    return base ** exponent

def log_message(level, message, timestamp=None):
    """记录日志"""
    import datetime
    if timestamp is None:
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    print(f"[{timestamp}] {level}: {message}")

# 创建偏函数
square = partial(power, exponent=2)
cube = partial(power, exponent=3)

info_log = partial(log_message, "INFO")
error_log = partial(log_message, "ERROR")
warning_log = partial(log_message, "WARNING")

# 使用偏函数
print(f"5的平方: {square(5)}")
print(f"3的立方: {cube(3)}")

info_log("程序启动")
warning_log("内存使用率较高")
error_log("数据库连接失败")
```

## 71. 函数缓存

```python
# 函数缓存
from functools import lru_cache
import time

@lru_cache(maxsize=128)
def expensive_function(n):
    """模拟耗时计算"""
    print(f"计算 expensive_function({n})")
    time.sleep(0.1)  # 模拟耗时操作
    return n * n * n

def manual_cache(func):
    """手动实现缓存装饰器"""
    cache = {}
    
    def wrapper(*args, **kwargs):
        key = str(args) + str(sorted(kwargs.items()))
        if key not in cache:
            cache[key] = func(*args, **kwargs)
            print(f"缓存未命中，计算结果")
        else:
            print(f"缓存命中，直接返回")
        return cache[key]
    
    wrapper.cache = cache
    return wrapper

@manual_cache
def fibonacci_cached(n):
    """带缓存的斐波那契数列"""
    if n <= 1:
        return n
    return fibonacci_cached(n - 1) + fibonacci_cached(n - 2)

# 测试缓存
print("测试LRU缓存:")
start_time = time.time()
result1 = expensive_function(5)
print(f"第一次调用耗时: {time.time() - start_time:.3f}秒")

start_time = time.time()
result2 = expensive_function(5)  # 从缓存获取
print(f"第二次调用耗时: {time.time() - start_time:.3f}秒")

print("\n测试手动缓存:")
result = fibonacci_cached(10)
print(f"fibonacci(10) = {result}")
```

## 72. 函数组合

```python
# 函数组合
def compose(*functions):
    """组合多个函数"""
    def composed_function(x):
        result = x
        for func in reversed(functions):
            result = func(result)
        return result
    return composed_function

def pipe(*functions):
    """管道式函数组合"""
    def piped_function(x):
        result = x
        for func in functions:
            result = func(result)
        return result
    return piped_function

# 基础函数
def add_ten(x):
    return x + 10

def multiply_by_two(x):
    return x * 2

def square(x):
    return x ** 2

# 组合函数
composed = compose(square, multiply_by_two, add_ten)
piped = pipe(add_ten, multiply_by_two, square)

# 测试函数组合
test_value = 5
print(f"原值: {test_value}")
print(f"组合函数结果: {composed(test_value)}")  # ((5+10)*2)^2 = 900
print(f"管道函数结果: {piped(test_value)}")      # ((5+10)*2)^2 = 900

# 链式调用示例
class Calculator:
    def __init__(self, value=0):
        self.value = value
    
    def add(self, x):
        self.value += x
        return self
    
    def multiply(self, x):
        self.value *= x
        return self
    
    def power(self, x):
        self.value **= x
        return self
    
    def result(self):
        return self.value

# 链式调用
result = Calculator(5).add(10).multiply(2).power(2).result()
print(f"链式调用结果: {result}")
```

## 73. 异步函数基础

```python
# 异步函数基础（需要Python 3.7+）
import asyncio
import time

async def async_task(name, duration):
    """异步任务"""
    print(f"任务 {name} 开始")
    await asyncio.sleep(duration)  # 模拟异步操作
    print(f"任务 {name} 完成")
    return f"任务 {name} 的结果"

async def fetch_data(url):
    """模拟异步获取数据"""
    print(f"开始获取 {url}")
    await asyncio.sleep(1)  # 模拟网络请求
    return f"来自 {url} 的数据"

async def main():
    """主异步函数"""
    print("开始异步操作")
    
    # 并发执行多个任务
    tasks = [
        async_task("任务1", 2),
        async_task("任务2", 1),
        async_task("任务3", 3)
    ]
    
    results = await asyncio.gather(*tasks)
    print(f"所有任务完成: {results}")
    
    # 并发获取数据
    urls = ["http://api1.com", "http://api2.com", "http://api3.com"]
    data_tasks = [fetch_data(url) for url in urls]
    data_results = await asyncio.gather(*data_tasks)
    print(f"获取的数据: {data_results}")

# 运行异步函数
if __name__ == "__main__":
    start_time = time.time()
    # asyncio.run(main())  # 取消注释来运行
    print(f"总耗时: {time.time() - start_time:.2f}秒")
```

## 74. 函数性能分析

```python
# 函数性能分析
import time
import functools
from memory_profiler import profile  # 需要安装: pip install memory-profiler

def timing_decorator(func):
    """计时装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()
        print(f"{func.__name__} 执行时间: {end_time - start_time:.6f}秒")
        return result
    return wrapper

def memory_usage_decorator(func):
    """内存使用装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        import tracemalloc
        tracemalloc.start()
        result = func(*args, **kwargs)
        current, peak = tracemalloc.get_traced_memory()
        tracemalloc.stop()
        print(f"{func.__name__} 内存使用: 当前 {current / 1024 / 1024:.2f}MB, 峰值 {peak / 1024 / 1024:.2f}MB")
        return result
    return wrapper

@timing_decorator
@memory_usage_decorator
def list_comprehension_test(n):
    """列表推导式性能测试"""
    return [x**2 for x in range(n)]

@timing_decorator
@memory_usage_decorator
def generator_test(n):
    """生成器性能测试"""
    return list(x**2 for x in range(n))

@timing_decorator
def loop_test(n):
    """循环性能测试"""
    result = []
    for x in range(n):
        result.append(x**2)
    return result

# 性能测试
print("性能测试 (n=100000):")
n = 100000

result1 = list_comprehension_test(n)
result2 = generator_test(n)
result3 = loop_test(n)

print(f"结果长度: {len(result1)}, {len(result2)}, {len(result3)}")
```

## 75. 函数文档和测试

```python
# 函数文档和测试
def calculate_bmi(weight, height):
    """
    计算身体质量指数(BMI)
    
    Args:
        weight (float): 体重，单位为千克
        height (float): 身高，单位为米
    
    Returns:
        float: BMI值
    
    Raises:
        ValueError: 当体重或身高为负数或零时
    
    Examples:
        >>> calculate_bmi(70, 1.75)
        22.857142857142858
        >>> calculate_bmi(80, 1.8)
        24.691358024691358
    """
    if weight <= 0 or height <= 0:
        raise ValueError("体重和身高必须为正数")
    
    bmi = weight / (height ** 2)
    return bmi

def get_bmi_category(bmi):
    """
    根据BMI值获取体重分类
    
    Args:
        bmi (float): BMI值
    
    Returns:
        str: 体重分类
    
    Examples:
        >>> get_bmi_category(18.5)
        '正常体重'
        >>> get_bmi_category(25)
        '超重'
    """
    if bmi < 18.5:
        return "体重过轻"
    elif bmi < 24:
        return "正常体重"
    elif bmi < 28:
        return "超重"
    else:
        return "肥胖"

# 单元测试
import unittest

class TestBMIFunctions(unittest.TestCase):
    def test_calculate_bmi(self):
        """测试BMI计算"""
        self.assertAlmostEqual(calculate_bmi(70, 1.75), 22.857, places=3)
        self.assertAlmostEqual(calculate_bmi(80, 1.8), 24.691, places=3)
    
    def test_calculate_bmi_invalid_input(self):
        """测试无效输入"""
        with self.assertRaises(ValueError):
            calculate_bmi(-70, 1.75)
        with self.assertRaises(ValueError):
            calculate_bmi(70, 0)
    
    def test_get_bmi_category(self):
        """测试BMI分类"""
        self.assertEqual(get_bmi_category(17), "体重过轻")
        self.assertEqual(get_bmi_category(20), "正常体重")
        self.assertEqual(get_bmi_category(26), "超重")
        self.assertEqual(get_bmi_category(30), "肥胖")

# 运行测试
if __name__ == "__main__":
    # 运行doctest
    import doctest
    doctest.testmod()
    
    # 运行unittest
    unittest.main(argv=[''], exit=False)
    
    # 实际使用示例
    try:
        weight = 70
        height = 1.75
        bmi = calculate_bmi(weight, height)
        category = get_bmi_category(bmi)
        print(f"\n体重: {weight}kg, 身高: {height}m")
        print(f"BMI: {bmi:.2f}, 分类: {category}")
    except ValueError as e:
        print(f"错误: {e}")
```

## 76. 函数式编程

```python
# 函数式编程
from functools import reduce
from operator import add, mul

# 高阶函数
def map_reduce_filter_example():
    """map, reduce, filter示例"""
    numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    
    # map: 应用函数到每个元素
    squared = list(map(lambda x: x**2, numbers))
    print(f"平方: {squared}")
    
    # filter: 过滤元素
    evens = list(filter(lambda x: x % 2 == 0, numbers))
    print(f"偶数: {evens}")
    
    # reduce: 累积操作
    sum_all = reduce(add, numbers)
    product_all = reduce(mul, numbers)
    print(f"求和: {sum_all}")
    print(f"求积: {product_all}")
    
    # 组合使用
    result = reduce(add, map(lambda x: x**2, filter(lambda x: x % 2 == 0, numbers)))
    print(f"偶数平方和: {result}")

# 纯函数示例
def pure_function(x, y):
    """纯函数：相同输入总是产生相同输出，无副作用"""
    return x * 2 + y

# 不纯函数示例
counter = 0
def impure_function(x):
    """不纯函数：有副作用"""
    global counter
    counter += 1
    return x + counter

# 柯里化
def curry_add(x):
    """柯里化加法函数"""
    def add_x(y):
        return x + y
    return add_x

# 测试函数式编程
map_reduce_filter_example()

print(f"\n纯函数测试:")
print(f"pure_function(3, 4) = {pure_function(3, 4)}")
print(f"pure_function(3, 4) = {pure_function(3, 4)}")  # 结果相同

print(f"\n不纯函数测试:")
print(f"impure_function(5) = {impure_function(5)}")
print(f"impure_function(5) = {impure_function(5)}")  # 结果不同

print(f"\n柯里化测试:")
add_5 = curry_add(5)
print(f"add_5(3) = {add_5(3)}")
print(f"add_5(7) = {add_5(7)}")
```

## 77. 动态函数创建

```python
# 动态函数创建
def create_validator(min_val, max_val):
    """创建验证器函数"""
    def validator(value):
        return min_val <= value <= max_val
    
    validator.__name__ = f"validate_{min_val}_to_{max_val}"
    validator.__doc__ = f"验证值是否在 {min_val} 到 {max_val} 之间"
    return validator

def create_operation(operation):
    """根据字符串创建运算函数"""
    operations = {
        'add': lambda x, y: x + y,
        'sub': lambda x, y: x - y,
        'mul': lambda x, y: x * y,
        'div': lambda x, y: x / y if y != 0 else None
    }
    return operations.get(operation)

# 使用exec动态创建函数
def create_function_from_string(func_name, func_body):
    """从字符串创建函数"""
    func_code = f"""
def {func_name}(x):
    {func_body}
"""
    
    local_vars = {}
    exec(func_code, globals(), local_vars)
    return local_vars[func_name]

# 测试动态函数创建
age_validator = create_validator(0, 150)
score_validator = create_validator(0, 100)

print(f"年龄验证 25: {age_validator(25)}")
print(f"年龄验证 200: {age_validator(200)}")
print(f"分数验证 85: {score_validator(85)}")
print(f"分数验证 150: {score_validator(150)}")

# 动态运算
add_func = create_operation('add')
mul_func = create_operation('mul')

print(f"\n动态运算:")
print(f"5 + 3 = {add_func(5, 3)}")
print(f"5 * 3 = {mul_func(5, 3)}")

# 从字符串创建函数
square_func = create_function_from_string('square', 'return x * x')
cube_func = create_function_from_string('cube', 'return x ** 3')

print(f"\n从字符串创建的函数:")
print(f"square(5) = {square_func(5)}")
print(f"cube(3) = {cube_func(3)}")
```

## 78. 函数重载模拟

```python
# 函数重载模拟
from functools import singledispatch
from typing import Union

class FunctionOverloader:
    """函数重载器"""
    def __init__(self):
        self.functions = {}
    
    def register(self, *types):
        """注册函数重载"""
        def decorator(func):
            key = tuple(types)
            self.functions[key] = func
            return func
        return decorator
    
    def __call__(self, *args):
        """调用匹配的函数"""
        arg_types = tuple(type(arg) for arg in args)
        
        # 精确匹配
        if arg_types in self.functions:
            return self.functions[arg_types](*args)
        
        # 尝试兼容匹配
        for types, func in self.functions.items():
            if len(types) == len(args):
                if all(isinstance(arg, expected_type) for arg, expected_type in zip(args, types)):
                    return func(*args)
        
        raise TypeError(f"没有找到匹配的函数重载: {arg_types}")

# 使用singledispatch实现重载
@singledispatch
def process_data(data):
    """处理数据的通用函数"""
    return f"处理未知类型数据: {type(data)}"

@process_data.register
def _(data: int):
    """处理整数"""
    return f"处理整数: {data * 2}"

@process_data.register
def _(data: str):
    """处理字符串"""
    return f"处理字符串: {data.upper()}"

@process_data.register
def _(data: list):
    """处理列表"""
    return f"处理列表: {len(data)} 个元素"

# 自定义重载器
calculate = FunctionOverloader()

@calculate.register(int, int)
def add_ints(a, b):
    return a + b

@calculate.register(str, str)
def add_strings(a, b):
    return a + " " + b

@calculate.register(list, list)
def add_lists(a, b):
    return a + b

# 测试函数重载
print("singledispatch测试:")
print(process_data(42))
print(process_data("hello"))
print(process_data([1, 2, 3]))
print(process_data(3.14))

print("\n自定义重载器测试:")
print(calculate(5, 3))
print(calculate("Hello", "World"))
print(calculate([1, 2], [3, 4]))

try:
    print(calculate(5, "3"))  # 会报错
except TypeError as e:
    print(f"错误: {e}")
```

## 79. 函数元编程

```python
# 函数元编程
import inspect
from types import FunctionType

def function_inspector(func):
    """函数检查器"""
    print(f"函数名: {func.__name__}")
    print(f"文档字符串: {func.__doc__}")
    print(f"模块: {func.__module__}")
    
    # 获取函数签名
    sig = inspect.signature(func)
    print(f"签名: {sig}")
    
    # 获取参数信息
    for param_name, param in sig.parameters.items():
        print(f"  参数 {param_name}: {param.kind}, 默认值: {param.default}")
    
    # 获取源代码
    try:
        source = inspect.getsource(func)
        print(f"源代码:\n{source}")
    except OSError:
        print("无法获取源代码")

def modify_function(func, new_name=None, new_doc=None):
    """修改函数属性"""
    if new_name:
        func.__name__ = new_name
    if new_doc:
        func.__doc__ = new_doc
    return func

def create_function_dynamically(name, args, body, globals_dict=None):
    """动态创建函数"""
    if globals_dict is None:
        globals_dict = {}
    
    # 创建函数代码
    func_code = f"def {name}({', '.join(args)}):\n    {body}"
    
    # 编译并执行
    compiled = compile(func_code, '<dynamic>', 'exec')
    local_dict = {}
    exec(compiled, globals_dict, local_dict)
    
    return local_dict[name]

# 函数装饰器工厂
def create_decorator(before_func=None, after_func=None):
    """创建装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            if before_func:
                before_func(func.__name__, args, kwargs)
            
            result = func(*args, **kwargs)
            
            if after_func:
                after_func(func.__name__, result)
            
            return result
        return wrapper
    return decorator

# 测试函数
def sample_function(x: int, y: str = "default") -> str:
    """示例函数"""
    return f"{y}: {x}"

# 测试元编程
print("函数检查:")
function_inspector(sample_function)

# 修改函数
modified_func = modify_function(sample_function, "new_sample", "新的文档字符串")
print(f"\n修改后的函数名: {modified_func.__name__}")
print(f"修改后的文档: {modified_func.__doc__}")

# 动态创建函数
dynamic_func = create_function_dynamically(
    "multiply", 
    ["a", "b"], 
    "return a * b"
)
print(f"\n动态函数结果: {dynamic_func(5, 3)}")

# 使用装饰器工厂
def log_before(func_name, args, kwargs):
    print(f"调用 {func_name}，参数: {args}, {kwargs}")

def log_after(func_name, result):
    print(f"{func_name} 返回: {result}")

logging_decorator = create_decorator(log_before, log_after)

@logging_decorator
def test_function(x, y):
    return x + y

print("\n装饰器测试:")
result = test_function(10, 20)
```

## 80. 函数性能优化

```python
# 函数性能优化
import time
import sys
from functools import lru_cache, wraps

# 尾递归优化
class TailRecursionOptimizer:
    """尾递归优化器"""
    def __init__(self, func):
        self.func = func
        self.firstcall = True
        self.CONTINUE = object()
    
    def __call__(self, *args, **kwargs):
        if self.firstcall:
            func = self.func
            CONTINUE = self.CONTINUE
            self.firstcall = False
            try:
                while True:
                    result = func(*args, **kwargs)
                    if result is CONTINUE:
                        continue
                    else:
                        return result
            finally:
                self.firstcall = True
        else:
            return self.CONTINUE

# 记忆化装饰器
def memoize(func):
    """记忆化装饰器"""
    cache = {}
    
    @wraps(func)
    def wrapper(*args, **kwargs):
        key = str(args) + str(sorted(kwargs.items()))
        if key not in cache:
            cache[key] = func(*args, **kwargs)
        return cache[key]
    
    wrapper.cache = cache
    wrapper.cache_clear = cache.clear
    return wrapper

# 性能测试函数
def performance_test(func, *args, iterations=1000):
    """性能测试"""
    start_time = time.perf_counter()
    for _ in range(iterations):
        result = func(*args)
    end_time = time.perf_counter()
    
    avg_time = (end_time - start_time) / iterations
    return result, avg_time

# 普通递归斐波那契
def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)

# 记忆化斐波那契
@memoize
def fibonacci_memoized(n):
    if n <= 1:
        return n
    return fibonacci_memoized(n - 1) + fibonacci_memoized(n - 2)

# 迭代斐波那契
def fibonacci_iterative(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

# 尾递归斐波那契
@TailRecursionOptimizer
def fibonacci_tail_recursive(n, a=0, b=1):
    if n == 0:
        return a
    if n == 1:
        return b
    return fibonacci_tail_recursive(n - 1, b, a + b)

# 性能比较
print("斐波那契数列性能比较 (n=30):")
n = 30

# 测试不同实现
result1, time1 = performance_test(fibonacci_iterative, n, 1000)
print(f"迭代版本: 结果={result1}, 平均时间={time1:.6f}秒")

result2, time2 = performance_test(fibonacci_memoized, n, 1000)
print(f"记忆化版本: 结果={result2}, 平均时间={time2:.6f}秒")

result3, time3 = performance_test(fibonacci_tail_recursive, n, 1000)
print(f"尾递归版本: 结果={result3}, 平均时间={time3:.6f}秒")

# 普通递归版本太慢，只测试一次
start = time.perf_counter()
result4 = fibonacci_recursive(n)
time4 = time.perf_counter() - start
print(f"普通递归版本: 结果={result4}, 时间={time4:.6f}秒")

# 内存使用优化示例
def memory_efficient_sum(numbers):
    """内存高效的求和（使用生成器）"""
    return sum(x for x in numbers)

def memory_inefficient_sum(numbers):
    """内存低效的求和（创建中间列表）"""
    return sum([x for x in numbers])

# 比较内存使用
import tracemalloc

def measure_memory(func, *args):
    """测量内存使用"""
    tracemalloc.start()
    result = func(*args)
    current, peak = tracemalloc.get_traced_memory()
    tracemalloc.stop()
    return result, current, peak

test_data = range(1000000)

print("\n内存使用比较:")
result1, current1, peak1 = measure_memory(memory_efficient_sum, test_data)
print(f"高效版本: 当前={current1/1024/1024:.2f}MB, 峰值={peak1/1024/1024:.2f}MB")

result2, current2, peak2 = measure_memory(memory_inefficient_sum, test_data)
print(f"低效版本: 当前={current2/1024/1024:.2f}MB, 峰值={peak2/1024/1024:.2f}MB")
```

# 面向对象练习

## 81. 类的基础定义

```python
# 类的基础定义
class Person:
    """人员类"""
    
    # 类变量
    species = "Homo sapiens"
    population = 0
    
    def __init__(self, name, age, gender):
        """初始化方法"""
        self.name = name        # 实例变量
        self.age = age
        self.gender = gender
        Person.population += 1  # 更新类变量
    
    def introduce(self):
        """自我介绍方法"""
        return f"我是{self.name}，今年{self.age}岁，性别{self.gender}"
    
    def have_birthday(self):
        """过生日方法"""
        self.age += 1
        print(f"{self.name}过生日了！现在{self.age}岁")
    
    @classmethod
    def get_population(cls):
        """类方法：获取人口数量"""
        return cls.population
    
    @staticmethod
    def is_adult(age):
        """静态方法：判断是否成年"""
        return age >= 18
    
    def __str__(self):
        """字符串表示"""
        return f"Person(name='{self.name}', age={self.age}, gender='{self.gender}')"
    
    def __repr__(self):
        """开发者表示"""
        return f"Person('{self.name}', {self.age}, '{self.gender}')"

# 使用类
print("创建Person对象:")
person1 = Person("张三", 25, "男")
person2 = Person("李四", 30, "女")

print(person1.introduce())
print(person2.introduce())

person1.have_birthday()
print(f"当前人口: {Person.get_population()}")
print(f"张三是否成年: {Person.is_adult(person1.age)}")
print(f"15岁是否成年: {Person.is_adult(15)}")

print(f"\nstr表示: {str(person1)}")
print(f"repr表示: {repr(person1)}")
```

## 82. 类的继承

```python
# 类的继承
class Animal:
    """动物基类"""
    
    def __init__(self, name, species):
        self.name = name
        self.species = species
    
    def make_sound(self):
        """发出声音（抽象方法）"""
        pass
    
    def move(self):
        """移动"""
        return f"{self.name}正在移动"
    
    def info(self):
        """基本信息"""
        return f"{self.name}是一只{self.species}"

class Dog(Animal):
    """狗类，继承自Animal"""
    
    def __init__(self, name, breed):
        super().__init__(name, "狗")
        self.breed = breed
    
    def make_sound(self):
        """重写父类方法"""
        return f"{self.name}汪汪叫"
    
    def fetch(self):
        """狗特有的方法"""
        return f"{self.name}去捡球"

class Cat(Animal):
    """猫类，继承自Animal"""
    
    def __init__(self, name, color):
        super().__init__(name, "猫")
        self.color = color
    
    def make_sound(self):
        """重写父类方法"""
        return f"{self.name}喵喵叫"
    
    def climb(self):
        """猫特有的方法"""
        return f"{self.name}爬树"

# 使用继承
dog = Dog("旺财", "金毛")
cat = Cat("咪咪", "橘色")

print("继承示例:")
print(dog.info())
print(dog.make_sound())
print(dog.move())
print(dog.fetch())

print("\n" + cat.info())
print(cat.make_sound())
print(cat.move())
print(cat.climb())

# 多态性
animals = [dog, cat]
print("\n多态性演示:")
for animal in animals:
    print(f"{animal.name}: {animal.make_sound()}")
```

## 83. 类的多重继承

```python
# 多重继承
class Flyable:
    """可飞行的混入类"""
    
    def fly(self):
        return f"{self.name}正在飞行"
    
    def land(self):
        return f"{self.name}降落了"

class Swimmable:
    """可游泳的混入类"""
    
    def swim(self):
        return f"{self.name}正在游泳"
    
    def dive(self):
        return f"{self.name}潜水了"

class Bird(Animal, Flyable):
    """鸟类，多重继承"""
    
    def __init__(self, name, wing_span):
        super().__init__(name, "鸟")
        self.wing_span = wing_span
    
    def make_sound(self):
        return f"{self.name}啾啾叫"

class Duck(Bird, Swimmable):
    """鸭子类，多重继承"""
    
    def __init__(self, name):
        super().__init__(name, "中等")
    
    def make_sound(self):
        return f"{self.name}嘎嘎叫"

# 使用多重继承
duck = Duck("唐老鸭")

print("多重继承示例:")
print(duck.info())
print(duck.make_sound())
print(duck.move())
print(duck.fly())
print(duck.swim())
print(duck.dive())

# 查看方法解析顺序
print(f"\nMRO: {Duck.__mro__}")
```

## 84. 属性装饰器

```python
# 属性装饰器
class Circle:
    """圆形类"""
    
    def __init__(self, radius):
        self._radius = radius
    
    @property
    def radius(self):
        """半径属性"""
        return self._radius
    
    @radius.setter
    def radius(self, value):
        """设置半径"""
        if value <= 0:
            raise ValueError("半径必须大于0")
        self._radius = value
    
    @property
    def area(self):
        """面积属性（只读）"""
        import math
        return math.pi * self._radius ** 2
    
    @property
    def circumference(self):
        """周长属性（只读）"""
        import math
        return 2 * math.pi * self._radius
    
    def __str__(self):
        return f"Circle(radius={self.radius})"

class Temperature:
    """温度类"""
    
    def __init__(self, celsius=0):
        self._celsius = celsius
    
    @property
    def celsius(self):
        """摄氏度"""
        return self._celsius
    
    @celsius.setter
    def celsius(self, value):
        if value < -273.15:
            raise ValueError("温度不能低于绝对零度")
        self._celsius = value
    
    @property
    def fahrenheit(self):
        """华氏度"""
        return self._celsius * 9/5 + 32
    
    @fahrenheit.setter
    def fahrenheit(self, value):
        self.celsius = (value - 32) * 5/9
    
    @property
    def kelvin(self):
        """开尔文"""
        return self._celsius + 273.15
    
    @kelvin.setter
    def kelvin(self, value):
        self.celsius = value - 273.15

# 使用属性装饰器
print("属性装饰器示例:")
circle = Circle(5)
print(f"圆: {circle}")
print(f"面积: {circle.area:.2f}")
print(f"周长: {circle.circumference:.2f}")

circle.radius = 10
print(f"\n修改半径后: {circle}")
print(f"面积: {circle.area:.2f}")

temp = Temperature(25)
print(f"\n温度转换:")
print(f"摄氏度: {temp.celsius}°C")
print(f"华氏度: {temp.fahrenheit:.1f}°F")
print(f"开尔文: {temp.kelvin:.1f}K")

temp.fahrenheit = 100
print(f"\n设置华氏度100°F后:")
print(f"摄氏度: {temp.celsius:.1f}°C")
```

## 85. 特殊方法（魔术方法）

```python
# 特殊方法
class Vector:
    """向量类"""
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        """字符串表示"""
        return f"Vector({self.x}, {self.y})"
    
    def __repr__(self):
        """开发者表示"""
        return f"Vector({self.x!r}, {self.y!r})"
    
    def __add__(self, other):
        """向量加法"""
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented
    
    def __sub__(self, other):
        """向量减法"""
        if isinstance(other, Vector):
            return Vector(self.x - other.x, self.y - other.y)
        return NotImplemented
    
    def __mul__(self, scalar):
        """标量乘法"""
        if isinstance(scalar, (int, float)):
            return Vector(self.x * scalar, self.y * scalar)
        return NotImplemented
    
    def __rmul__(self, scalar):
        """右乘法"""
        return self.__mul__(scalar)
    
    def __eq__(self, other):
        """相等比较"""
        if isinstance(other, Vector):
            return self.x == other.x and self.y == other.y
        return False
    
    def __abs__(self):
        """向量长度"""
        return (self.x ** 2 + self.y ** 2) ** 0.5
    
    def __bool__(self):
        """布尔值"""
        return bool(abs(self))
    
    def __getitem__(self, index):
        """索引访问"""
        if index == 0:
            return self.x
        elif index == 1:
            return self.y
        else:
            raise IndexError("向量索引超出范围")
    
    def __setitem__(self, index, value):
        """索引设置"""
        if index == 0:
            self.x = value
        elif index == 1:
            self.y = value
        else:
            raise IndexError("向量索引超出范围")
    
    def __len__(self):
        """长度（维度）"""
        return 2

# 使用特殊方法
print("特殊方法示例:")
v1 = Vector(3, 4)
v2 = Vector(1, 2)

print(f"v1 = {v1}")
print(f"v2 = {v2}")
print(f"v1 + v2 = {v1 + v2}")
print(f"v1 - v2 = {v1 - v2}")
print(f"v1 * 2 = {v1 * 2}")
print(f"3 * v1 = {3 * v1}")
print(f"|v1| = {abs(v1)}")
print(f"v1 == v2: {v1 == v2}")
print(f"bool(v1): {bool(v1)}")
print(f"bool(Vector(0, 0)): {bool(Vector(0, 0))}")
print(f"v1[0] = {v1[0]}, v1[1] = {v1[1]}")
print(f"len(v1) = {len(v1)}")

v1[0] = 5
print(f"修改后 v1 = {v1}")
```

## 86. 类的组合

```python
# 类的组合
class Engine:
    """引擎类"""
    
    def __init__(self, power, fuel_type):
        self.power = power  # 功率
        self.fuel_type = fuel_type  # 燃料类型
        self.running = False
    
    def start(self):
        """启动引擎"""
        self.running = True
        return f"引擎启动，功率{self.power}马力"
    
    def stop(self):
        """停止引擎"""
        self.running = False
        return "引擎停止"
    
    def __str__(self):
        status = "运行中" if self.running else "停止"
        return f"Engine({self.power}HP, {self.fuel_type}, {status})"

class Wheel:
    """轮子类"""
    
    def __init__(self, size, brand):
        self.size = size
        self.brand = brand
    
    def __str__(self):
        return f"Wheel({self.size}inch, {self.brand})"

class Car:
    """汽车类（组合）"""
    
    def __init__(self, make, model, engine, wheels):
        self.make = make
        self.model = model
        self.engine = engine  # 组合引擎
        self.wheels = wheels  # 组合轮子列表
        self.speed = 0
    
    def start(self):
        """启动汽车"""
        return self.engine.start()
    
    def stop(self):
        """停止汽车"""
        self.speed = 0
        return self.engine.stop()
    
    def accelerate(self, increment):
        """加速"""
        if self.engine.running:
            self.speed += increment
            return f"加速到{self.speed}km/h"
        return "请先启动引擎"
    
    def brake(self, decrement):
        """刹车"""
        self.speed = max(0, self.speed - decrement)
        return f"减速到{self.speed}km/h"
    
    def info(self):
        """汽车信息"""
        wheel_info = ", ".join(str(wheel) for wheel in self.wheels)
        return f"{self.make} {self.model}\n引擎: {self.engine}\n轮子: {wheel_info}\n速度: {self.speed}km/h"

# 使用组合
print("类的组合示例:")
engine = Engine(200, "汽油")
wheels = [Wheel(18, "米其林") for _ in range(4)]
car = Car("丰田", "凯美瑞", engine, wheels)

print(car.info())
print("\n" + car.start())
print(car.accelerate(50))
print(car.accelerate(30))
print(car.brake(20))
print("\n" + car.info())
print(car.stop())
```

## 87. 抽象基类

```python
# 抽象基类
from abc import ABC, abstractmethod

class Shape(ABC):
    """抽象形状类"""
    
    @abstractmethod
    def area(self):
        """计算面积（抽象方法）"""
        pass
    
    @abstractmethod
    def perimeter(self):
        """计算周长（抽象方法）"""
        pass
    
    def description(self):
        """具体方法"""
        return f"这是一个{self.__class__.__name__}"

class Rectangle(Shape):
    """矩形类"""
    
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        """实现抽象方法"""
        return self.width * self.height
    
    def perimeter(self):
        """实现抽象方法"""
        return 2 * (self.width + self.height)
    
    def __str__(self):
        return f"Rectangle({self.width}x{self.height})"

class Circle(Shape):
    """圆形类"""
    
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        """实现抽象方法"""
        import math
        return math.pi * self.radius ** 2
    
    def perimeter(self):
        """实现抽象方法"""
        import math
        return 2 * math.pi * self.radius
    
    def __str__(self):
        return f"Circle(radius={self.radius})"

def print_shape_info(shape):
    """打印形状信息"""
    print(f"{shape}")
    print(f"描述: {shape.description()}")
    print(f"面积: {shape.area():.2f}")
    print(f"周长: {shape.perimeter():.2f}")
    print()

# 使用抽象基类
print("抽象基类示例:")
rectangle = Rectangle(5, 3)
circle = Circle(4)

shapes = [rectangle, circle]
for shape in shapes:
    print_shape_info(shape)

# 尝试实例化抽象类会报错
# shape = Shape()  # TypeError
```

## 88. 单例模式

```python
# 单例模式
class Singleton:
    """单例模式实现"""
    _instance = None
    _initialized = False
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        if not self._initialized:
            self.value = 0
            self._initialized = True
    
    def increment(self):
        self.value += 1
    
    def get_value(self):
        return self.value

class DatabaseConnection:
    """数据库连接单例"""
    _instance = None
    _lock = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.connected = False
            cls._instance.connection_count = 0
        return cls._instance
    
    def connect(self):
        """连接数据库"""
        if not self.connected:
            self.connected = True
            self.connection_count += 1
            return f"数据库连接成功，连接次数: {self.connection_count}"
        return "数据库已连接"
    
    def disconnect(self):
        """断开连接"""
        if self.connected:
            self.connected = False
            return "数据库连接已断开"
        return "数据库未连接"
    
    def query(self, sql):
        """执行查询"""
        if self.connected:
            return f"执行SQL: {sql}"
        return "请先连接数据库"

# 使用单例模式
print("单例模式示例:")
s1 = Singleton()
s2 = Singleton()

print(f"s1 is s2: {s1 is s2}")  # True
print(f"s1.get_value(): {s1.get_value()}")

s1.increment()
print(f"s1.increment()后 s2.get_value(): {s2.get_value()}")

db1 = DatabaseConnection()
db2 = DatabaseConnection()

print(f"\ndb1 is db2: {db1 is db2}")  # True
print(db1.connect())
print(db2.connect())  # 已连接
print(db1.query("SELECT * FROM users"))
print(db2.disconnect())
print(db1.query("SELECT * FROM users"))  # 需要重新连接
```

## 89. 上下文管理器

```python
# 上下文管理器
class FileManager:
    """文件管理器上下文管理器"""
    
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None
    
    def __enter__(self):
        """进入上下文"""
        print(f"打开文件: {self.filename}")
        self.file = open(self.filename, self.mode, encoding='utf-8')
        return self.file
    
    def __exit__(self, exc_type, exc_value, traceback):
        """退出上下文"""
        if self.file:
            print(f"关闭文件: {self.filename}")
            self.file.close()
        
        if exc_type is not None:
            print(f"发生异常: {exc_type.__name__}: {exc_value}")
            return False  # 不抑制异常
        return True

class Timer:
    """计时器上下文管理器"""
    
    def __init__(self, name="操作"):
        self.name = name
        self.start_time = None
    
    def __enter__(self):
        """开始计时"""
        import time
        self.start_time = time.time()
        print(f"开始{self.name}...")
        return self
    
    def __exit__(self, exc_type, exc_value, traceback):
        """结束计时"""
        import time
        end_time = time.time()
        duration = end_time - self.start_time
        print(f"{self.name}完成，耗时: {duration:.4f}秒")
        return False

from contextlib import contextmanager

@contextmanager
def database_transaction():
    """数据库事务上下文管理器"""
    print("开始事务")
    try:
        yield "数据库连接"
        print("提交事务")
    except Exception as e:
        print(f"回滚事务: {e}")
        raise
    finally:
        print("关闭连接")

# 使用上下文管理器
print("上下文管理器示例:")

# 文件管理器
with FileManager("test.txt", "w") as f:
    f.write("Hello, World!")
    f.write("\n这是测试文件")

with FileManager("test.txt", "r") as f:
    content = f.read()
    print(f"文件内容: {content}")

# 计时器
with Timer("数据处理"):
    import time
    time.sleep(0.1)  # 模拟耗时操作
    result = sum(range(1000000))

# 数据库事务
with database_transaction() as db:
    print(f"使用{db}执行操作")
    # 模拟数据库操作
```

## 90. 元类基础

```python
# 元类基础
class SingletonMeta(type):
    """单例元类"""
    _instances = {}
    
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super().__call__(*args, **kwargs)
        return cls._instances[cls]

class Database(metaclass=SingletonMeta):
    """使用单例元类的数据库类"""
    
    def __init__(self):
        self.connected = False
    
    def connect(self):
        self.connected = True
        return "数据库连接成功"

class ValidatedMeta(type):
    """验证元类"""
    
    def __new__(mcs, name, bases, namespace):
        # 验证类必须有特定方法
        required_methods = ['validate']
        for method in required_methods:
            if method not in namespace:
                raise TypeError(f"类{name}必须实现{method}方法")
        
        # 自动添加验证装饰器
        for key, value in namespace.items():
            if callable(value) and not key.startswith('_'):
                namespace[key] = mcs.add_validation(value)
        
        return super().__new__(mcs, name, bases, namespace)
    
    @staticmethod
    def add_validation(func):
        """添加验证装饰器"""
        def wrapper(self, *args, **kwargs):
            if hasattr(self, 'validate'):
                self.validate()
            return func(self, *args, **kwargs)
        return wrapper

class User(metaclass=ValidatedMeta):
    """使用验证元类的用户类"""
    
    def __init__(self, name, email):
        self.name = name
        self.email = email
    
    def validate(self):
        """验证方法"""
        if not self.name:
            raise ValueError("姓名不能为空")
        if '@' not in self.email:
            raise ValueError("邮箱格式不正确")
    
    def get_info(self):
        """获取信息"""
        return f"用户: {self.name}, 邮箱: {self.email}"
    
    def update_email(self, new_email):
        """更新邮箱"""
        self.email = new_email
        return "邮箱更新成功"

# 使用元类
print("元类示例:")

# 单例元类
db1 = Database()
db2 = Database()
print(f"db1 is db2: {db1 is db2}")  # True

# 验证元类
user = User("张三", "zhangsan@example.com")
print(user.get_info())
print(user.update_email("newemail@example.com"))

# 尝试创建无效用户
try:
    invalid_user = User("", "invalid-email")
    invalid_user.get_info()  # 会触发验证
except ValueError as e:
    print(f"验证失败: {e}")
```

