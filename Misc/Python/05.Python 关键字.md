# False 布尔值为假

# True 布尔值为真

# if-elif-else 条件语句

```python
if  条件1：
    条件1为真(ture)时执行代码
elif 条件2：
    条件2为真(ture)时执行代码
else：
    当条件判断为假(false)时执行代码
```
举例：

```python
# 获取用户输入的数字
number = float(input("请输入一个数字："))

# 使用if-elif-else结构来判断数字的正负
if number > 0:
    print("这个数字是正数。")
elif number < 0:
    print("这个数字是负数。")
else:
    print("这个数字是零。")
```

# import 用于导入模块
```python
import math
import os, sys
import math as m
from math import sqrt
```
# as
`as`用于为导入的模块、类、函数或变量指定一个别名。

# from
`from`关键字通常与`import`关键字一起使用，用于从模块中导入特定的名称（如函数、类、变量等）。

# pass
`pass`作为占位符：在编写代码时，如果你已经定义了一个函数或类，但还没有想好怎么实现它，可以使用`pass`作为占位符，这样代码就可以正常地运行而不会抛出语法错误。

`pass`是一个有用的工具，特别是在代码开发初期，它允许程序员在构思整个程序的结构时，先构建出框架，再逐步填充细节。

举例：
```python
def my_function():
    pass  # 后续会实现具体功能

class MyClass:
    pass  # 类的内容以后再添加
```
# def 用于定义一个函数。

# None 
`None`是一个特殊的常量，它表示空值或者没有值。

# break

`break`用于提前退出循环结构

举例：
```python
# 模拟猜数字游戏
secret_number = 7

while True:
    guess = int(input("猜一个数字（1-10）："))
    if guess == secret_number:
        print("恭喜你，猜对了！")
        break
    elif guess < secret_number:
        print("猜低了。")
    else:
        print("猜高了。")
```
# continue
`continue`用于跳过当前循环的剩余部分，并开始下一次循环迭代。它通常用于`for`和`while`循环中，当你想要跳过某些特定的迭代，但不希望完全结束循环时使用。

举例：
```python
for i in range(1, 11):
    if i % 2 == 0:  # 如果i是偶数
        continue  # 跳过本次迭代
    print(i)  # 只打印奇数
```

# try-except 用于异常处理

举例：
```python
try:
    # 尝试执行可能会引发错误的代码
    result = 10 / 0  # 这是一个会导致ZeroDivisionError的操作
except ZeroDivisionError:
    # 如果尝试除以零，执行这个块
    print("你不能除以零！")
```

# in 
`in`用于检查一个对象是否存在于序列（如字符串、列表、元组）或集合（如字典、集合）中。`in`通常与`for`循环一起使用。

举例：
```python
if 'banana' in fruits:
    print("香蕉在水果列表中")
```
在这个例子中，若`'banana'`在列表`fruits`中，返回`ture`，执行`if`下的语句。

# class 用于定义一个新类。

举例：

```python
class Dog:
    # 类的属性
    species = 'Canis familiaris'

    # 初始化方法，用于创建实例时初始化属性
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # 类的方法
    def bark(self):
        return "Woof!"

# 创建Dog类的实例
my_dog = Dog(name='Buddy', age=3)

# 访问实例属性
print(f"My dog's name is {my_dog.name} and he is {my_dog.age} years old.")

# 调用实例方法
print(f"{my_dog.name} says {my_dog.bark()}.")

```

# finally

`finally`与`try`和`except`语句一起使用，用于定义一个无论是否发生异常都会执行的代码块。`finally`块通常用于释放资源、关闭文件、网络连接或执行任何必要的清理工作。

举例：
```python
try:
    # 尝试执行可能会引发异常的代码
    file = open('example.txt', 'r')
    content = file.read()
except FileNotFoundError:
    # 如果文件不存在，执行这个块
    print("文件未找到")
finally:
    # 无论是否发生异常，都会执行这个块
    print("执行finally块")
    if 'file' in locals() and not file.closed:
        file.close()
```

# is 
`is`是一个身份运算符，用于比较两个对象的身份，即它们是否是同一个对象。`is`运算符不比较对象的内容或值，而是比较它们的内存地址。如果两个对象在内存中占据相同的位置，那么`is`运算符的结果为`True`，否则为`False`。

举例：
```python
a = 1000
b = 1000
print(a is b)  # 可能输出True或False，取决于Python的实现和版本
```

# return
`return`用于从函数中返回一个值。当`return`语句执行时，函数会立即停止执行，并且将`return`后面的值传递给调用者。如果一个函数没有`return`语句，或者`return`语句后没有任何值，那么函数会返回一个`None`值。

举例：
```python
def add(a, b):
    return a + b

result = add(3, 4)
print(result)  # 输出7
```
# `and` `or` `not`
在Python中，`and`、`or`和`not`是逻辑运算符，用于组合布尔表达式。这些运算符允许你根据多个条件进行决策。
`and`运算符：
如果两个表达式都为`True`，则`and`表达式的结果为`True`。
如果任一表达式为`False`，则`and`表达式的结果为`False`。

举例：

```python
x = 5
y = 10
if x > 0 and y > 0:
    print("x和y都是正数")
```
## or运算符：
如果任一表达式为`True`，则`or`表达式的结果为`True`。
如果两个表达式都为`False`，则`or`表达式的结果为`False`。

举例：
```python
x = -5
y = 10
if x > 0 or y > 0:
    print("x或y至少有一个是正数")
```
## not运算符：
如果表达式为`True`，则`not`表达式的结果为`False`。
如果表达式为`False`，则`not`表达式的结果为`True`。

举例：
```python
x = 5
if not x < 0:
    print("x不是负数")
```

# for
`for`用于遍历序列（如列表、元组、字典、集合、字符串）或任何可迭代对象。`for`循环可以遍历序列中的每个元素，并执行一系列的语句。

举例：
```python
# 定义一个列表
fruits = ['apple', 'banana', 'cherry', 'date']

# 使用for循环遍历列表
for fruit in fruits:
    print(fruit)
```
# while 用于创建一个循环
```python
# 定义一个变量用于计数
count = 0

# 使用while循环，只要count小于10，循环就会继续执行
while count < 10:
    print(f"Count is {count}")
    count += 1

# 当count等于10时，循环结束
print("Count is now 10, so the loop has ended.")
```

# lambda
`lambda`用于创建匿名函数，也称为`lambda`函数。`lambda`函数是一种单行的函数定义，它没有函数名，只有一个表达式，并且返回这个表达式的值。`lambda`函数通常用于创建简单的、一次性的函数，特别是在需要函数作为参数传递给其他函数时。




# assert 断言

# del 删除

举例：

```python
del my_dict
del my_dict['key1']
```
# global
`global`关键字用于声明一个变量，表明该变量是全局变量。全局变量是在函数外部定义的变量，它们在函数内部可以使用`global`关键字进行访问和修改。

举例：
```python
global_var = 10

def change_global_var():
    global global_var
    global_var += 1

change_global_var()
print(global_var)  # 输出11
```
# nonlocal
在Python中，`nonlocal`关键字用于在函数内部声明一个变量，表明该变量不是局部变量，也不是全局变量，而是定义在函数外部但不在全局作用域中的变量。换句话说，`nonlocal`关键字用于函数内部访问和修改函数外部的变量，这些变量在函数外部被另一个函数定义。

举例：
```python
def outer_function():
    outer_var = 10

    def inner_function():
        nonlocal outer_var
        outer_var += 1
        print(f"Inner function: {outer_var}")

    inner_function()
    print(f"Outer function: {outer_var}")

outer_function()
```

# with
`with`语句用于确保代码块中的资源被正确地管理和释放。`with`语句通常用于文件操作、数据库连接、网络资源或其他需要资源管理的操作。

使用`with`语句的好处是，它可以帮助你避免常见的资源泄漏问题，如文件未关闭、数据库连接未释放等。当`with`语句块执行完毕时，它会自动执行一个清理操作，这通常是通过调用一个`__enter__()`方法来开始操作，然后调用一个`__exit__()`方法来结束操作。

举例：
```python
with open('example.txt', 'r') as file:
    content = file.read()
    print(content)
```
在这个例子中，我们使用`with`语句打开一个名为`example.txt`的文件，并将其内容读取到变量`content`中。当``with``语句块执行完毕时，它会自动关闭文件，确保文件被正确地关闭，即使程序在执行过程中出现异常，文件也会被关闭。


# yield
在Python中，`yield`关键字用于在生成器（generator）函数中创建一个迭代器。生成器函数是那些在每次调用时产生一系列值而不是一个单一值的可迭代对象。

下面是一个使用`yield`关键字的例子：
```python
def my_generator():
    for i in range(5):
        yield i
# 创建生成器对象
gen = my_generator()
# 遍历生成器
for value in gen:
    print(value)
```
在这个例子中，我们定义了一个名为`my_generator`的生成器函数。函数内部使用`yield`关键字来产生一系列值。每次`yield`语句被执行时，它会返回一个值，并暂停函数的执行。当调用者再次请求下一个值时，函数从上一次`yield`语句暂停的地方继续执行，直到遇到下一个`yield`语句或函数结束。
生成器函数的基本结构如下：
```python
def generator_function():
    while condition:
        yield value
```
- `condition`：一个布尔表达式，用于控制生成器何时停止。
- `value`：每次`yield`语句返回的值。
生成器函数通常用于创建可迭代对象，这些对象可以按需生成值，而不是一次性生成所有值。这使得生成器在处理大量数据或进行网络请求时非常有用，因为它可以减少内存的使用并提高性能。

# await  async 用于异步编程

举例：
```python
async def hello():
    print("Hello, world!")

# 调用异步函数
await hello()
```

# raise 用于引发一个异常。